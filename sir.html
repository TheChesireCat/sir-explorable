<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SIR Interactive</title>
  <style>
    :root {
      --bg-1: #f8f3ea;
      --bg-2: #e4f2ef;
      --ink: #1e1c1a;
      --muted: #5a5752;
      --panel: #fffdf8;
      --accent: #d66a33;
      --accent-2: #2f7f75;
      --accent-3: #b33a3a;
      --grid: rgba(30, 28, 26, 0.12);
      --shadow: 0 10px 30px rgba(30, 28, 26, 0.12);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      color: var(--ink);
      font-family: "Trebuchet MS", "Lucida Sans", sans-serif;
      background: radial-gradient(circle at 12% 12%, rgba(255,255,255,0.9), rgba(255,255,255,0) 55%),
                  linear-gradient(135deg, var(--bg-1), var(--bg-2));
      min-height: 100vh;
    }

    .app {
      max-width: 1200px;
      margin: 0 auto;
      padding: 28px 24px 40px;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 24px;
      margin-bottom: 24px;
      animation: rise 0.6s ease-out both;
    }

    h1 {
      margin: 0 0 8px 0;
      font-family: "Palatino Linotype", "Book Antiqua", Palatino, serif;
      font-size: clamp(1.8rem, 2.4vw, 2.6rem);
      letter-spacing: 0.5px;
    }

    header p {
      margin: 0;
      color: var(--muted);
      max-width: 560px;
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(2, minmax(140px, 1fr));
      gap: 12px 16px;
      background: var(--panel);
      border-radius: 16px;
      padding: 14px 16px;
      box-shadow: var(--shadow);
      min-width: 280px;
    }

    .controls label {
      font-size: 0.85rem;
      color: var(--muted);
      display: flex;
      flex-direction: column;
      gap: 6px;
      transition: opacity 0.2s ease;
    }

    .controls input {
      font-size: 0.95rem;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(30, 28, 26, 0.2);
      background: #ffffff;
    }

    .controls input[type="range"] {
      width: 100%;
      padding: 0;
    }
    .controls input[type="checkbox"] {
      width: 18px;
      height: 18px;
    }

    .slider-readout {
      font-size: 0.8rem;
      color: var(--muted);
    }

    .control-hidden {
      opacity: 0;
      pointer-events: none;
    }

    .control-disabled {
      opacity: 0.45;
    }

    .layout {
      display: grid;
      grid-template-columns: minmax(260px, 320px) 1fr;
      gap: 20px;
      align-items: stretch;
    }

    .panel.selector { }
    .panel.plot { }

    .panel {
      background: var(--panel);
      border-radius: 20px;
      padding: 16px;
      box-shadow: var(--shadow);
      animation: rise 0.6s ease-out both;
    }

    .panel:nth-of-type(2) { animation-delay: 0.05s; }

    .panel h2 {
      margin: 0 0 12px;
      font-size: 1.1rem;
      letter-spacing: 0.3px;
    }

    .selector-toggle {
      display: none;
      align-items: center;
      justify-content: center;
      gap: 6px;
      font-size: 0.85rem;
      line-height: 1;
      padding: 0;
      width: 20px;
      height: 20px;
      border: none;
      border-radius: 0;
      background: transparent;
      color: var(--muted);
      cursor: pointer;
      position: absolute;
      top: 8px;
      right: 8px;
      z-index: 2;
    }

    .selector-backdrop {
      display: none;
    }

    .selector-wrap {
      position: relative;
      width: 100%;
      aspect-ratio: 1 / 1;
      border-radius: 14px;
      overflow: hidden;
      border: 1px solid rgba(30, 28, 26, 0.12);
      touch-action: none;
    }

    .selector-label {
      position: absolute;
      font-size: 0.75rem;
      color: var(--muted);
      pointer-events: none;
    }

    .label-x { bottom: 8px; left: 50%; transform: translateX(-50%); }
    .label-y { top: 50%; left: 8px; transform: rotate(-90deg) translateX(-50%); transform-origin: left center; }

    .readout {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 14px;
      font-size: 0.9rem;
    }

    .readout span {
      display: inline-block;
      padding: 8px 10px;
      border-radius: 10px;
      background: rgba(214, 106, 51, 0.08);
    }

    .equations {
      margin-top: 14px;
      font-size: 0.9rem;
      color: var(--muted);
      line-height: 1.5;
    }

    .equations h3 {
      margin: 0 0 6px;
      font-size: 0.95rem;
      color: var(--ink);
    }

    .equation-wrap {
      position: relative;
    }

    .equations .math {
      padding: 8px 10px;
      border-radius: 10px;
      background: rgba(47, 127, 117, 0.08);
      min-height: 6.5em;
    }

    .equation-hint {
      position: absolute;
      top: 6px;
      right: 8px;
    }

    .equation-icon {
      width: 20px;
      height: 20px;
      border-radius: 999px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 0.75rem;
      font-weight: 700;
      background: rgba(30, 28, 26, 0.1);
      color: var(--ink);
      cursor: help;
      user-select: none;
    }

    .equation-tooltip {
      position: absolute;
      top: 26px;
      right: 0;
      width: 220px;
      padding: 8px 10px;
      border-radius: 10px;
      background: rgba(30, 28, 26, 0.92);
      color: #fff;
      font-size: 0.75rem;
      line-height: 1.4;
      opacity: 0;
      pointer-events: none;
      transform: translateY(-4px);
      transition: opacity 0.2s ease, transform 0.2s ease;
      box-shadow: 0 10px 24px rgba(30, 28, 26, 0.25);
    }

    .equation-hint:hover .equation-tooltip,
    .equation-hint:focus-within .equation-tooltip,
    .equation-hint.is-open .equation-tooltip {
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
    }

    .plot-wrap {
      position: relative;
      width: 100%;
      height: 420px;
    }

    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 8px;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .legend span {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .legend-item-hidden {
      opacity: 0;
      pointer-events: none;
    }

    .swatch {
      width: 14px;
      height: 2px;
      border-radius: 999px;
      background: var(--accent);
    }

    .swatch.s { background: var(--accent-2); }
    .swatch.i { background: var(--accent-3); }
    .swatch.dash {
      background: transparent;
      height: 0;
      border-top: 2px dashed var(--accent-3);
    }
    .swatch.dot {
      background: transparent;
      height: 0;
      border-top: 2px dotted var(--accent-3);
    }
    .swatch.band {
      height: 10px;
      border-radius: 4px;
      background: rgba(179, 58, 58, 0.18);
      border: 1px solid rgba(179, 58, 58, 0.35);
    }

    #pathIMedian,
    #pathIP75,
    #pathIP25 {
      fill: none;
      stroke: var(--accent-3);
      stroke-width: 2;
      opacity: 0.65;
    }

    #pathIMedian {
      stroke-dasharray: 7 4;
      opacity: 0.85;
    }

    #pathIP75,
    #pathIP25 {
      stroke-dasharray: 3 4;
    }

    .run-line {
      fill: none;
      stroke: var(--accent-3);
      stroke-width: 1;
      opacity: 0.12;
    }

    .mode-toggle {
      display: inline-flex;
      border-radius: 999px;
      border: 1px solid rgba(30, 28, 26, 0.2);
      overflow: hidden;
    }

    .mode-toggle button {
      background: #ffffff;
      border: none;
      padding: 6px 12px;
      font-size: 0.85rem;
      color: var(--muted);
      cursor: pointer;
    }

    .mode-toggle button.active {
      background: rgba(47, 127, 117, 0.14);
      color: var(--ink);
      font-weight: 600;
    }

    .plot-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 6px;
    }

    .plot-actions {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .pill {
      font-size: 0.75rem;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px dashed rgba(30, 28, 26, 0.3);
      color: var(--muted);
      background: rgba(255, 255, 255, 0.7);
    }

    .help {
      position: relative;
    }

    .help-button {
      width: 28px;
      height: 28px;
      border-radius: 999px;
      border: 1px solid rgba(30, 28, 26, 0.2);
      background: #ffffff;
      color: var(--muted);
      font-size: 0.95rem;
      cursor: pointer;
    }

    .help-popover {
      position: absolute;
      right: 0;
      top: 36px;
      width: min(320px, 80vw);
      background: var(--panel);
      border-radius: 14px;
      padding: 12px 14px;
      box-shadow: var(--shadow);
      border: 1px solid rgba(30, 28, 26, 0.1);
      display: none;
      z-index: 5;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .help-popover.is-open { display: block; }

    .help-popover h4 {
      margin: 0 0 6px;
      color: var(--ink);
      font-size: 0.9rem;
    }

    .help-popover ul {
      margin: 0 0 8px 18px;
      padding: 0;
    }

    footer {
      margin-top: 22px;
      color: var(--muted);
      font-size: 0.85rem;
    }

    @keyframes rise {
      from { opacity: 0; transform: translateY(12px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @media (max-width: 960px) {
      .selector-backdrop {
        display: block;
        position: fixed;
        inset: 0;
        background: rgba(30, 28, 26, 0.12);
        backdrop-filter: blur(1px);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease;
        z-index: 40;
      }
      .selector-backdrop.is-open {
        opacity: 1;
        pointer-events: auto;
      }
      header {
        flex-direction: column;
        align-items: flex-start;
      }
      .controls { width: 100%; }
      .layout { grid-template-columns: 1fr; }
      .plot-wrap { height: auto; aspect-ratio: 800 / 420; }
      .panel.plot { order: -1; }
      .panel.selector { order: 0; }
      .panel.selector {
        position: fixed;
        right: 16px;
        bottom: 16px;
        z-index: 50;
        width: 160px;
        max-width: calc(100vw - 32px);
        padding: 12px;
        border-radius: 18px;
        box-shadow: 0 12px 28px rgba(30, 28, 26, 0.18);
        transition: width 0.2s ease, height 0.2s ease;
      }
      .panel.selector .selector-toggle { display: inline-flex; }
      .panel.selector .selector-wrap { margin: 0 auto; }
      .panel.selector.collapsed h2,
      .panel.selector.collapsed .readout,
      .panel.selector.collapsed .equations { display: none; }
      .panel.selector.collapsed .selector-wrap { width: 140px; }
      .panel.selector.is-open { width: min(92vw, 380px); }
      .panel.selector.is-open .selector-wrap { width: 100%; }
    }
  </style>
</head>
<body>
  <div id="selectorBackdrop" class="selector-backdrop" aria-hidden="true"></div>
  <div class="app">
    <header>
      <div>
        <h1>Disease Dynamics Explorable</h1>
        <p>Based on the classic Kermack&ndash;McKendrick SIR model. Read the original paper: <a href="https://jxshix.people.wm.edu/2009-harbin-course/classic/Kermack-McKendrick-1927-I.pdf" target="_blank" rel="noreferrer">Kermack &amp; McKendrick (1927)</a>.</p>
        <p>Click or drag in the box to set <strong>&beta;</strong> and <strong>&mu;</strong>. Toggle between deterministic and stochastic simulations.</p>
      </div>
      <div class="controls">
        <label>
          Population N
          <input id="inputN" type="range" min="10" max="10000" step="10" value="200" />
          <div class="slider-readout">N = <span id="inputNValue">200</span></div>
        </label>
        <label>
          Time steps
          <input id="inputSteps" type="number" min="10" max="1000" step="10" value="500" />
        </label>
        <label id="runsControl">
          Runs (mean/std)
          <input id="inputRuns" type="range" min="5" max="200" step="5" value="150" />
          <div class="slider-readout">Runs = <span id="inputRunsValue">150</span></div>
        </label>
        <label id="allRunsControl">
          Show all runs (I)
          <input id="inputAllRuns" type="checkbox" />
          <div class="slider-readout">Faint trajectories for each stochastic run</div>
        </label>
        <label>
          Initial infected I0
          <input id="inputI0" type="range" min="1" max="50" step="1" value="1" />
          <div class="slider-readout">I0 = <span id="inputI0Value">1</span></div>
        </label>
        <label>
          Initial recovered R0
          <input id="inputR0" type="number" min="0" max="50" step="1" value="0" />
        </label>
      </div>
    </header>

    <div class="layout">
      <section class="panel selector">
        <h2>Choose &beta; and &mu;</h2>
        <div class="selector-wrap">
          <button id="selectorToggle" class="selector-toggle" type="button" aria-expanded="false" aria-label="Expand parameters">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-expand-icon lucide-expand" aria-hidden="true" focusable="false">
              <path d="m15 15 6 6"/>
              <path d="m15 9 6-6"/>
              <path d="M21 16v5h-5"/>
              <path d="M21 8V3h-5"/>
              <path d="M3 16v5h5"/>
              <path d="m3 21 6-6"/>
              <path d="M3 8V3h5"/>
              <path d="M9 9 3 3"/>
            </svg>
          </button>
          <svg id="paramBox" viewBox="0 0 100 100" preserveAspectRatio="none" style="width:100%;height:100%;display:block;">
            <defs>
              <linearGradient id="paramGrad" x1="0" y1="0" x2="1" y2="1">
                <stop offset="0%" stop-color="#fff6e4" />
                <stop offset="100%" stop-color="#e6f5f2" />
              </linearGradient>
            </defs>
            <rect x="0" y="0" width="100" height="100" fill="url(#paramGrad)" />
            <g stroke="rgba(30,28,26,0.12)" stroke-width="0.5">
              <line x1="20" y1="0" x2="20" y2="100" />
              <line x1="40" y1="0" x2="40" y2="100" />
              <line x1="60" y1="0" x2="60" y2="100" />
              <line x1="80" y1="0" x2="80" y2="100" />
              <line x1="0" y1="20" x2="100" y2="20" />
              <line x1="0" y1="40" x2="100" y2="40" />
              <line x1="0" y1="60" x2="100" y2="60" />
              <line x1="0" y1="80" x2="100" y2="80" />
            </g>
            <line x1="0" y1="100" x2="100" y2="0" stroke="rgba(30,28,26,0.35)" stroke-width="0.6" stroke-dasharray="2 2" />
            <circle id="paramDot" cx="30" cy="90" r="3.6" fill="#d66a33" stroke="#1e1c1a" stroke-width="0.6" />
          </svg>
          <div class="selector-label label-x">&beta; (infection)</div>
          <div class="selector-label label-y">&mu; (recovery)</div>
        </div>
        <div class="readout">
          <span id="betaReadout">&beta; = 0.30</span>
          <span id="muReadout">&mu; = 0.10</span>
        </div>
        <div class="equations">
          <h3 id="equationTitle">Deterministic SIR</h3>
          <div class="equation-wrap">
            <div id="equationBody" class="math"></div>
            <div id="equationHint" class="equation-hint">
              <button id="equationHelpBtn" class="equation-icon" type="button" aria-label="Equation help" aria-expanded="false" aria-controls="equationTooltip">i</button>
              <div id="equationTooltip" class="equation-tooltip" role="tooltip"></div>
            </div>
          </div>
        </div>
      </section>

      <section class="panel plot">
        <div class="plot-header">
          <h2>Population curves</h2>
          <div class="plot-actions">
            <div class="mode-toggle" role="group" aria-label="Simulation mode">
              <button id="modeDet" type="button" class="active" data-mode="det">Deterministic</button>
              <button id="modeStoch" type="button" data-mode="stoch">Stochastic</button>
            </div>
            <span class="pill">SI / SIS coming soon</span>
            <div class="help">
              <button id="helpButton" class="help-button" type="button" aria-label="How to use">?</button>
              <div id="helpPopover" class="help-popover" role="dialog" aria-hidden="true">
                <h4>How to use</h4>
                <ul>
                  <li>Drag the dot in the square to set &beta; (infection) and &mu; (recovery).</li>
                  <li>Use N and steps to change population size and timeline length.</li>
                  <li>Deterministic shows smooth averages; stochastic shows mean, median, and 25th/75th percentiles (plus 1&sigma; band).</li>
                </ul>
                <h4>Variables</h4>
                <ul>
                  <li>S, I, R: susceptible, infected, recovered counts.</li>
                  <li>&beta;: infection rate per contact.</li>
                  <li>&mu;: recovery probability per step.</li>
                </ul>
              </div>
            </div>
          </div>
        </div>
        <div class="plot-wrap">
          <svg id="plot" viewBox="0 0 800 420" preserveAspectRatio="xMidYMid meet" style="width:100%;height:100%;display:block;">
            <rect x="0" y="0" width="800" height="420" fill="#fffdf8" />
            <g id="axes" stroke="rgba(30,28,26,0.35)" stroke-width="1">
              <line id="xAxis" x1="60" y1="360" x2="780" y2="360" />
              <line id="yAxis" x1="60" y1="40" x2="60" y2="360" />
            </g>
            <g id="grid" stroke="rgba(30,28,26,0.08)" stroke-width="1"></g>
            <g id="yTicks" fill="#5a5752" font-size="12" font-family="Trebuchet MS"></g>
            <g id="xTicks" fill="#5a5752" font-size="12" font-family="Trebuchet MS"></g>
            <path id="bandI" fill="rgba(179, 58, 58, 0.18)" stroke="none" />
            <g id="allRunsGroup" pointer-events="none"></g>
            <path id="pathS" fill="none" stroke="#2f7f75" stroke-width="2.5" />
            <path id="pathI" fill="none" stroke="#b33a3a" stroke-width="2.5" />
            <path id="pathIMedian" />
            <path id="pathIP75" />
            <path id="pathIP25" />
            <path id="pathR" fill="none" stroke="#d66a33" stroke-width="2.5" />
            <g id="labels" fill="#5a5752" font-size="12" font-family="Trebuchet MS">
              <text id="labelN" x="70" y="24">N = 200</text>
              <text id="labelSteps" x="140" y="24">steps = 100</text>
            </g>
          </svg>
        </div>
        <div class="legend">
          <span><span class="swatch s"></span>Susceptible</span>
          <span><span class="swatch i"></span>Infected (mean)</span>
          <span><span class="swatch"></span>Recovered</span>
          <span id="medianLegend"><span class="swatch dash"></span>I median</span>
          <span id="percentileLegend"><span class="swatch dot"></span>I 25th / 75th percentile</span>
          <span id="bandLegend"><span class="swatch band"></span>I &plusmn; 1&sigma;</span>
        </div>
      </section>
    </div>

    <footer>
      Tip: drag smoothly for continuous updates. Stochastic mode uses fewer runs while dragging, then refines on release.
    </footer>
  </div>

  <script>
    const state = {
      mode: 'det',
      beta: 0.3,
      mu: 0.1,
      N: 200,
      steps: 500,
      I0: 1,
      R0: 0,
      runs: 150,
      showAllRuns: false
    };

    const paramBox = document.getElementById('paramBox');
    const paramDot = document.getElementById('paramDot');
    const betaReadout = document.getElementById('betaReadout');
    const muReadout = document.getElementById('muReadout');
    const plot = document.getElementById('plot');
    const bandI = document.getElementById('bandI');
    const allRunsGroup = document.getElementById('allRunsGroup');
    const pathS = document.getElementById('pathS');
    const pathI = document.getElementById('pathI');
    const pathIMedian = document.getElementById('pathIMedian');
    const pathIP75 = document.getElementById('pathIP75');
    const pathIP25 = document.getElementById('pathIP25');
    const pathR = document.getElementById('pathR');
    const grid = document.getElementById('grid');
    const yTicks = document.getElementById('yTicks');
    const xTicks = document.getElementById('xTicks');
    const labelN = document.getElementById('labelN');
    const labelSteps = document.getElementById('labelSteps');
    const bandLegend = document.getElementById('bandLegend');
    const medianLegend = document.getElementById('medianLegend');
    const percentileLegend = document.getElementById('percentileLegend');
    const equationTitle = document.getElementById('equationTitle');
    const equationBody = document.getElementById('equationBody');
    const equationTooltip = document.getElementById('equationTooltip');
    const equationHint = document.getElementById('equationHint');
    const equationHelpBtn = document.getElementById('equationHelpBtn');

    const inputN = document.getElementById('inputN');
    const inputNValue = document.getElementById('inputNValue');
    const inputSteps = document.getElementById('inputSteps');
    const inputRuns = document.getElementById('inputRuns');
    const inputRunsValue = document.getElementById('inputRunsValue');
    const inputAllRuns = document.getElementById('inputAllRuns');
    const inputI0 = document.getElementById('inputI0');
    const inputI0Value = document.getElementById('inputI0Value');
    const inputR0 = document.getElementById('inputR0');
    const runsControl = document.getElementById('runsControl');
    const allRunsControl = document.getElementById('allRunsControl');

    const selectorPanel = document.querySelector('.panel.selector');
    const selectorToggle = document.getElementById('selectorToggle');
    const selectorBackdrop = document.getElementById('selectorBackdrop');
    const mobileQuery = window.matchMedia('(max-width: 960px)');

    const modeDet = document.getElementById('modeDet');
    const modeStoch = document.getElementById('modeStoch');
    const helpButton = document.getElementById('helpButton');
    const helpPopover = document.getElementById('helpPopover');

    let scheduled = false;
    let dragging = false;
    let isMobileInitialized = false;

    const equations = {
      det: {
        title: 'Deterministic SIR',
        body: (
          '$$S_{t+1} = S_t - \\beta \\frac{I_t}{N} S_t$$' +
          '$$I_{t+1} = I_t + \\beta \\frac{I_t}{N} S_t - \\mu I_t$$' +
          '$$R_{t+1} = R_t + \\mu I_t$$'
        ),
        help: 'Shows the expected change per step. Infection scales with contacts (beta I/N) and recovery removes a fraction mu of I.'
      },
      stoch: {
        title: 'Stochastic SIR',
        body: (
          '$$S_{t+1} = S_t - \\mathrm{Bin}(S_t, \\lambda_t)$$' +
          '$$I_{t+1} = I_t + \\mathrm{Bin}(S_t, \\lambda_t) - \\mathrm{Bin}(I_t, \\mu)$$' +
          '$$R_{t+1} = R_t + \\mathrm{Bin}(I_t, \\mu)$$' +
          '$$\\lambda_t = 1 - (1 - \\beta / N)^{I_t}$$'
        ),
        help: 'Infections and recoveries are random binomial draws each step. Lambda is the per-susceptible infection probability from I contacts.'
      }
    };

    function clamp(value, min, max) {
      return Math.min(Math.max(value, min), max);
    }

    function mulberry32(seed) {
      let t = seed >>> 0;
      return function rng() {
        t += 0x6D2B79F5;
        let x = t;
        x = Math.imul(x ^ (x >>> 15), x | 1);
        x ^= x + Math.imul(x ^ (x >>> 7), x | 61);
        return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
      };
    }

    function randomNormal(rng) {
      let u = 0;
      let v = 0;
      while (u === 0) u = rng();
      while (v === 0) v = rng();
      return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }

    function binomial(n, p, rng) {
      if (n <= 0 || p <= 0) return 0;
      if (p >= 1) return n;
      if (n < 25) {
        let x = 0;
        for (let i = 0; i < n; i++) {
          if (rng() < p) x += 1;
        }
        return x;
      }
      const mean = n * p;
      const std = Math.sqrt(n * p * (1 - p));
      const z = randomNormal(rng);
      const val = Math.round(mean + std * z);
      return clamp(val, 0, n);
    }

    function setDot() {
      const cx = state.beta * 100;
      const cy = (1 - state.mu) * 100;
      paramDot.setAttribute('cx', cx.toFixed(2));
      paramDot.setAttribute('cy', cy.toFixed(2));
      betaReadout.innerHTML = `&beta; = ${state.beta.toFixed(2)}`;
      muReadout.innerHTML = `&mu; = ${state.mu.toFixed(2)}`;
    }

    function scheduleRender() {
      if (scheduled) return;
      scheduled = true;
      requestAnimationFrame(() => {
        scheduled = false;
        render();
      });
    }

    function simulateDeterministic() {
      const steps = state.steps;
      const N = state.N;
      const I0 = clamp(state.I0, 1, N);
      const R0 = clamp(state.R0, 0, N - I0);
      const S0 = N - I0 - R0;
      const S = new Float64Array(steps);
      const I = new Float64Array(steps);
      const R = new Float64Array(steps);
      S[0] = S0;
      I[0] = I0;
      R[0] = R0;
      for (let t = 0; t < steps - 1; t++) {
        const newInf = state.beta * (I[t] / N) * S[t];
        const newRec = state.mu * I[t];
        S[t + 1] = S[t] - newInf;
        I[t + 1] = I[t] + newInf - newRec;
        R[t + 1] = R[t] + newRec;
      }
      return { S, I, R };
    }

    function simulateStochastic(runCount) {
      const steps = state.steps;
      const N = state.N;
      const I0 = clamp(state.I0, 1, N);
      const R0 = clamp(state.R0, 0, N - I0);
      const S0 = N - I0 - R0;

      const meanS = new Float64Array(steps);
      const meanI = new Float64Array(steps);
      const meanR = new Float64Array(steps);
      const m2I = new Float64Array(steps);
      const iSamples = Array.from({ length: steps }, () => new Int32Array(runCount));

      const S = new Int32Array(steps);
      const I = new Int32Array(steps);
      const R = new Int32Array(steps);

      const seedBase = (
        Math.floor(state.beta * 1e6) ^
        Math.floor(state.mu * 1e5) ^
        (state.N << 4) ^
        (state.steps << 2) ^
        (state.I0 * 101) ^
        (state.R0 * 37)
      ) >>> 0;

      for (let r = 0; r < runCount; r++) {
        const rng = mulberry32((seedBase + r * 1013) >>> 0);
        S[0] = S0;
        I[0] = I0;
        R[0] = R0;

        for (let t = 0; t < steps - 1; t++) {
          const lambda = 1 - Math.pow(1 - state.beta / N, I[t]);
          const newInf = binomial(S[t], lambda, rng);
          const newRec = binomial(I[t], state.mu, rng);
          S[t + 1] = S[t] - newInf;
          I[t + 1] = I[t] + newInf - newRec;
          R[t + 1] = R[t] + newRec;
        }

        const k = r + 1;
        for (let t = 0; t < steps; t++) {
          iSamples[t][r] = I[t];
          meanS[t] += (S[t] - meanS[t]) / k;
          meanR[t] += (R[t] - meanR[t]) / k;

          const deltaI = I[t] - meanI[t];
          meanI[t] += deltaI / k;
          m2I[t] += deltaI * (I[t] - meanI[t]);
        }
      }

      const stdI = new Float64Array(steps);
      if (runCount > 1) {
        for (let t = 0; t < steps; t++) {
          stdI[t] = Math.sqrt(m2I[t] / (runCount - 1));
        }
      }

      const medianI = new Float64Array(steps);
      const p75I = new Float64Array(steps);
      const p25I = new Float64Array(steps);
      for (let t = 0; t < steps; t++) {
        const values = Array.from(iSamples[t]);
        values.sort((a, b) => a - b);
        medianI[t] = quantile(values, 0.5);
        p75I[t] = quantile(values, 0.75);
        p25I[t] = quantile(values, 0.25);
      }

      return { meanS, meanI, meanR, stdI, medianI, p75I, p25I, iSamples };
    }

    function buildPath(series, width, height, maxY, pad) {
      const n = series.length;
      const xStep = n > 1 ? width / (n - 1) : 0;
      let d = '';
      for (let i = 0; i < n; i++) {
        const x = pad.left + i * xStep;
        const y = pad.top + (1 - series[i] / maxY) * height;
        d += i === 0 ? `M${x.toFixed(2)},${y.toFixed(2)}` : `L${x.toFixed(2)},${y.toFixed(2)}`;
      }
      return d;
    }

    function buildBand(mean, std, width, height, maxY, pad) {
      const n = mean.length;
      if (n === 0) return '';
      const xStep = n > 1 ? width / (n - 1) : 0;
      let d = '';
      for (let i = 0; i < n; i++) {
        const upper = clamp(mean[i] + std[i], 0, maxY);
        const x = pad.left + i * xStep;
        const y = pad.top + (1 - upper / maxY) * height;
        d += i === 0 ? `M${x.toFixed(2)},${y.toFixed(2)}` : `L${x.toFixed(2)},${y.toFixed(2)}`;
      }
      for (let i = n - 1; i >= 0; i--) {
        const lower = clamp(mean[i] - std[i], 0, maxY);
        const x = pad.left + i * xStep;
        const y = pad.top + (1 - lower / maxY) * height;
        d += `L${x.toFixed(2)},${y.toFixed(2)}`;
      }
      return d + 'Z';
    }

    function buildRunLines(samples, width, height, maxY, pad) {
      const steps = samples.length;
      if (!steps) return '';
      const runs = samples[0].length;
      const xStep = steps > 1 ? width / (steps - 1) : 0;
      let markup = '';
      for (let r = 0; r < runs; r++) {
        let d = '';
        for (let t = 0; t < steps; t++) {
          const x = pad.left + t * xStep;
          const y = pad.top + (1 - samples[t][r] / maxY) * height;
          d += t === 0 ? `M${x.toFixed(2)},${y.toFixed(2)}` : `L${x.toFixed(2)},${y.toFixed(2)}`;
        }
        markup += `<path class="run-line" d="${d}" />`;
      }
      return markup;
    }

    function quantile(sortedValues, q) {
      if (!sortedValues.length) return 0;
      const pos = (sortedValues.length - 1) * q;
      const base = Math.floor(pos);
      const rest = pos - base;
      const next = sortedValues[base + 1];
      return next === undefined ? sortedValues[base] : sortedValues[base] + rest * (next - sortedValues[base]);
    }

    function drawGrid(width, height, pad) {
      const lines = [];
      const ticks = 4;
      for (let i = 1; i <= ticks; i++) {
        const x = pad.left + (width * i) / (ticks + 1);
        const y = pad.top + (height * i) / (ticks + 1);
        lines.push(`<line x1="${x}" y1="${pad.top}" x2="${x}" y2="${pad.top + height}" />`);
        lines.push(`<line x1="${pad.left}" y1="${y}" x2="${pad.left + width}" y2="${y}" />`);
      }
      grid.innerHTML = lines.join('');
    }

    function drawYTicks(maxY, height, pad) {
      const labels = [];
      const ticks = 4;
      for (let i = 0; i <= ticks; i++) {
        const value = Math.round((maxY * i) / ticks);
        const y = pad.top + (1 - value / maxY) * height;
        labels.push(
          `<text x="${pad.left - 8}" y="${y.toFixed(2)}" text-anchor="end" dominant-baseline="middle">${value}</text>`
        );
      }
      yTicks.innerHTML = labels.join('');
    }

    function drawXTicks(maxX, width, height, pad) {
      const labels = [];
      const ticks = 4;
      for (let i = 0; i <= ticks; i++) {
        const value = Math.round((maxX * i) / ticks);
        const x = pad.left + (width * i) / ticks;
        const y = pad.top + height + 18;
        labels.push(
          `<text x="${x.toFixed(2)}" y="${y.toFixed(2)}" text-anchor="middle" dominant-baseline="hanging">${value}</text>`
        );
      }
      xTicks.innerHTML = labels.join('');
    }

    function updateModeUI() {
      modeDet.classList.toggle('active', state.mode === 'det');
      modeStoch.classList.toggle('active', state.mode === 'stoch');
      const isStoch = state.mode === 'stoch';
      if (runsControl) {
        runsControl.classList.toggle('control-disabled', !isStoch);
        inputRuns.disabled = !isStoch;
      }
      if (allRunsControl) {
        allRunsControl.classList.toggle('control-disabled', !isStoch);
        inputAllRuns.disabled = !isStoch;
      }
      bandLegend.classList.toggle('legend-item-hidden', !isStoch);
      medianLegend.classList.toggle('legend-item-hidden', !isStoch);
      percentileLegend.classList.toggle('legend-item-hidden', !isStoch);
      bandI.style.display = isStoch ? 'block' : 'none';
      allRunsGroup.style.display = isStoch ? 'block' : 'none';
      pathIMedian.style.display = isStoch ? 'block' : 'none';
      pathIP75.style.display = isStoch ? 'block' : 'none';
      pathIP25.style.display = isStoch ? 'block' : 'none';

      const eq = equations[state.mode];
      equationTitle.textContent = eq.title;
      equationBody.innerHTML = eq.body;
      if (equationTooltip) {
        equationTooltip.textContent = eq.help;
      }
      if (window.MathJax && window.MathJax.typesetPromise) {
        window.MathJax.typesetPromise([equationBody]);
      }
    }

    function render() {
      const plotBox = plot.viewBox.baseVal;
      const pad = { left: 60, right: 20, top: 40, bottom: 60 };
      const width = plotBox.width - pad.left - pad.right;
      const height = plotBox.height - pad.top - pad.bottom;
      const maxY = state.N;

      if (state.mode === 'det') {
        const { S, I, R } = simulateDeterministic();
        pathS.setAttribute('d', buildPath(S, width, height, maxY, pad));
        pathI.setAttribute('d', buildPath(I, width, height, maxY, pad));
        pathIMedian.setAttribute('d', '');
        pathIP75.setAttribute('d', '');
        pathIP25.setAttribute('d', '');
        pathR.setAttribute('d', buildPath(R, width, height, maxY, pad));
        bandI.setAttribute('d', '');
        allRunsGroup.innerHTML = '';
      } else {
        const runCount = dragging ? Math.max(5, Math.round(state.runs / 5)) : state.runs;
        const { meanS, meanI, meanR, stdI, medianI, p75I, p25I, iSamples } = simulateStochastic(runCount);
        bandI.setAttribute('d', buildBand(meanI, stdI, width, height, maxY, pad));
        pathS.setAttribute('d', buildPath(meanS, width, height, maxY, pad));
        pathI.setAttribute('d', buildPath(meanI, width, height, maxY, pad));
        pathIMedian.setAttribute('d', buildPath(medianI, width, height, maxY, pad));
        pathIP75.setAttribute('d', buildPath(p75I, width, height, maxY, pad));
        pathIP25.setAttribute('d', buildPath(p25I, width, height, maxY, pad));
        pathR.setAttribute('d', buildPath(meanR, width, height, maxY, pad));
        allRunsGroup.innerHTML = state.showAllRuns ? buildRunLines(iSamples, width, height, maxY, pad) : '';
        labelSteps.textContent = `steps = ${state.steps}, runs = ${runCount}${dragging ? ' (preview)' : ''}`;
      }

      drawGrid(width, height, pad);
      drawYTicks(maxY, height, pad);
      drawXTicks(state.steps - 1, width, height, pad);

      labelN.textContent = `N = ${state.N}`;
      if (state.mode === 'det') {
        labelSteps.textContent = `steps = ${state.steps}`;
      }
    }

    function updateParamFromEvent(event) {
      const rect = paramBox.getBoundingClientRect();
      const x = clamp(event.clientX - rect.left, 0, rect.width);
      const y = clamp(event.clientY - rect.top, 0, rect.height);
      state.beta = x / rect.width;
      state.mu = 1 - y / rect.height;
      setDot();
      scheduleRender();
    }

    function setSelectorState(isOpen) {
      if (!selectorPanel) return;
      selectorPanel.classList.toggle('is-open', isOpen);
      selectorPanel.classList.toggle('collapsed', !isOpen);
      if (selectorBackdrop) {
        selectorBackdrop.classList.toggle('is-open', isOpen && mobileQuery.matches);
      }
      if (selectorToggle) {
        selectorToggle.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
      }
    }

    function syncSelectorForViewport() {
      if (!selectorPanel || !mobileQuery) return;
      if (mobileQuery.matches) {
        if (!isMobileInitialized) {
          setSelectorState(false);
          isMobileInitialized = true;
        }
      } else {
        selectorPanel.classList.remove('collapsed');
        selectorPanel.classList.remove('is-open');
        if (selectorBackdrop) {
          selectorBackdrop.classList.remove('is-open');
        }
        if (selectorToggle) {
          selectorToggle.setAttribute('aria-expanded', 'true');
        }
        isMobileInitialized = false;
      }
    }

    paramBox.addEventListener('pointerdown', (event) => {
      event.preventDefault();
      dragging = true;
      paramBox.setPointerCapture(event.pointerId);
      updateParamFromEvent(event);
    });

    paramBox.addEventListener('pointermove', (event) => {
      if (!dragging) return;
      event.preventDefault();
      updateParamFromEvent(event);
    });

    paramBox.addEventListener('pointerup', () => {
      dragging = false;
      scheduleRender();
    });

    paramBox.addEventListener('pointercancel', () => {
      dragging = false;
    });

    [inputN, inputSteps, inputRuns, inputI0, inputR0].forEach((input) => {
      input.addEventListener('input', () => {
        state.N = Math.max(10, parseInt(inputN.value, 10) || state.N);
        state.steps = Math.max(10, parseInt(inputSteps.value, 10) || state.steps);
        state.runs = clamp(parseInt(inputRuns.value, 10) || state.runs, 5, 400);
        state.I0 = Math.max(1, parseInt(inputI0.value, 10) || state.I0);
        state.R0 = Math.max(0, parseInt(inputR0.value, 10) || state.R0);
        inputNValue.textContent = state.N;
        inputRunsValue.textContent = state.runs;
        if (inputI0Value) {
          inputI0Value.textContent = state.I0;
        }
        scheduleRender();
      });
    });

    if (inputAllRuns) {
      inputAllRuns.addEventListener('change', () => {
        state.showAllRuns = inputAllRuns.checked;
        scheduleRender();
      });
    }

    modeDet.addEventListener('click', () => {
      state.mode = 'det';
      updateModeUI();
      scheduleRender();
    });

    modeStoch.addEventListener('click', () => {
      state.mode = 'stoch';
      updateModeUI();
      scheduleRender();
    });

    if (selectorToggle && selectorPanel) {
      selectorToggle.addEventListener('click', (event) => {
        event.stopPropagation();
        const isOpen = selectorPanel.classList.contains('is-open');
        setSelectorState(!isOpen);
      });
    }

    if (selectorBackdrop) {
      selectorBackdrop.addEventListener('click', () => {
        setSelectorState(false);
      });
    }

    if (mobileQuery) {
      mobileQuery.addEventListener('change', syncSelectorForViewport);
    }

    if (helpButton && helpPopover) {
      helpButton.addEventListener('click', (event) => {
        event.stopPropagation();
        const isOpen = helpPopover.classList.toggle('is-open');
        helpPopover.setAttribute('aria-hidden', isOpen ? 'false' : 'true');
      });

      document.addEventListener('click', (event) => {
        if (!helpPopover.classList.contains('is-open')) return;
        if (helpPopover.contains(event.target) || helpButton.contains(event.target)) return;
        helpPopover.classList.remove('is-open');
        helpPopover.setAttribute('aria-hidden', 'true');
      });
    }

    function setEquationTooltipOpen(isOpen) {
      if (!equationHint || !equationHelpBtn) return;
      equationHint.classList.toggle('is-open', isOpen);
      equationHelpBtn.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
    }

    if (equationHelpBtn && equationHint) {
      equationHelpBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        const isOpen = equationHint.classList.contains('is-open');
        setEquationTooltipOpen(!isOpen);
      });

      document.addEventListener('click', (event) => {
        if (!equationHint.classList.contains('is-open')) return;
        if (equationHint.contains(event.target)) return;
        setEquationTooltipOpen(false);
      });
    }

    setDot();
    inputNValue.textContent = state.N;
    inputRunsValue.textContent = state.runs;
    if (inputI0Value) {
      inputI0Value.textContent = state.I0;
    }
    state.showAllRuns = inputAllRuns ? inputAllRuns.checked : false;
    updateModeUI();
    syncSelectorForViewport();
    render();
  </script>
  <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>
